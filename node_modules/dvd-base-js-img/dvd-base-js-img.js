import type from 'dvd-base-js-type';
import qrcode from 'dvd-base-js-qrcode';
import mime from 'mime/lite';
import exif from 'exif-js';
import ajaxFileUpload from 'dvd-service-js-ajax-file-upload';

/**
 * @class Img
 * @namespace Img
 * @classdesc 自定义Image类型，包含图片处理的一些列方法，new Img()之后需要调用init()方法才能进行后续操作
 * @author sunweiguang [源码地址](http://gitlab.rd.vyohui.com/FE-Base/dvd-base-js-img.git)
 * @example
 * http://gitlab.rd.vyohui.com/FE-Service/npm-test.git
 * http://bravetime.davdian.com/npm-test/dvd-base-com-img-clip.html
 */
export default class Img {
  /**
   * @property origin
   * @type {{}}
   * @desc 初始化时接收的原始数据
   */
  origin = null;

  /**
   * @property base64
   * @type {{}}
   * @desc origin为File时，构造函数会将File转换为base64，此处保存一份
   */
  base64 = null;

  /**
   * @property image
   * @type {Image}
   * @desc Image类型的对象
   */
  image = null;

  /**
   * @property isLoaded
   * @type {Boolean}
   * @desc image对象是否已加载
   */
  isLoaded = false;

  /**
   * @property url
   * @type {String}
   * @desc 图片url
   */
  url = null;

  /**
   * @constructor
   * @desc 接受初始化参数
   * @param image {String(url)|File|Blob|Image}
   */
  constructor(img) {
    // 将参数赋值给原始数据属性
    this.origin = img;
  }

  /**
   * @method init
   * @async
   * @desc 异步初始化Img，初始化完成后image属性会被赋值为已加载完图片的Image类型
   * @returns {Promise}
   */
  async init() {
    // 如果是文件，则转成base64，并且用base64加载图片
    if (this.origin instanceof File || this.origin instanceof Blob) {
      this.url = this.base64 = await Img.blobToBase64(this.origin);
      await this.load();

      // 如果是url，则直接加载图片
    } else if (type.isString(this.origin)) {
      this.url = this.origin;
      if (this.origin.indexOf('base64') !== -1) {
        this.base64 = this.origin;
      }
      await this.load();

      // 如果是Image类型，直接赋值
    } else if (this.origin instanceof Image) {
      this.image = this.origin;
      // 入参类型错误
    } else {
      throw new Error(`img必须为有效的图片类型：{String(url)|File|Image}，实际检测为：${img}`);
    }

    // 获取图像元数据
    exif.getData(this.image);

    // 纠正方向
    await this.correctionOrientation();
  }

  /**
   * @method load
   * @desc 加载图片，加载后image属性才会有值
   * @param url {String}
   * @returns {Promise}
   */
  async load(url = this.url || this.base64) {
    this.image = new Image();

    // 此处需要和CORS配合使用，否则画布导出时会提示画布污染
    this.image.crossOrigin = 'anonymous';

    await new Promise((resolve, reject) => {
      // 图片加载成功
      this.image.addEventListener('load', () => {
        this.isLoaded = true;
        resolve();
      }, false);

      // 图片加载失败
      this.image.addEventListener('error', (event) => {

        // 因某些浏览器限制DataUrl长度，具体长度限制因内核而异
        if (this.image.src && this.image.src.indexOf('data:image') !== -1 && this.image.src.length > 1000) {
          // reject(`受当前运行环境限制图片体积过大无法解析。通过以下方法之一可以解决：1.升级手机系统到最新版；2.使用最新版谷歌浏览器或QQ浏览器；3.使用最新版微信；4.提前压缩您要操作的图片。给您带来的不便请见谅~`);
          // 转换成普通url重新加载
          let blob = Img.base64ToBlob(this.image.src);
          let ext = Img.getImgExt(this.image.src);
          let file = Img.blobToFile(blob, `xxx.${ext}`, ext);
          ajaxFileUpload.uploadFile({
            dir: 'base64_to_url',
            files: [file],
          }).then((data) => {
            this.url = data[0];
            this.image.src = this.url;
          }, (err) => {
            console.error(err);
            reject(err);
          });

          // 其他错误
        } else {
          reject(`图片加载失败：${event.target.src}`);
        }
      }, false);

      // 图片开始加载
      this.image.src = url;
    });
  }

  /**
   * @method load
   * @desc 加载图片，加载后image属性才会有值
   * @param url {String}
   * @returns {Promise}
   */
  async correctionOrientation() {
    // 是否需要纠正方向
    if (!this.image.exifdata || !this.image.exifdata.Orientation || this.image.exifdata.Orientation === 1) return;

    let base64 = null;
    // 90deg
    if (this.image.exifdata.Orientation === 8) {
      base64 = this.turn(false);
      // 180deg
    } else if (this.image.exifdata.Orientation === 3) {
      await this.turn(true);
      await this.turn(true);
      // 270deg
    } else if (this.image.exifdata.Orientation === 6) {
      await this.turn(true);
    }
  }


  /**
   * @method turn
   * @desc 旋转图片，目前只支持90度旋转
   * @param isClockwise 顺时针(true)、逆时针(false)
   */
  async turn(isClockwise = true) {
    // 生成canvas
    let canvas = document.createElement('canvas');

    // 因为即将旋转90度，所以新的宽=旧的高、新的高=旧的宽
    canvas.width = this.image.naturalHeight;
    canvas.height = this.image.naturalWidth;

    // 生成画布，大小与canvas相同
    let context = canvas.getContext('2d');

    // 顺时针旋转90度
    if (isClockwise) {
      // 绘制起始点移动到画布右端（X轴末端）
      context.translate(canvas.width, 0);
      // 绘制以起始点为中心顺时针旋转90度
      context.rotate(2 * Math.PI * 90 / 360);
      // 逆时针旋转90度
    } else {
      // 绘制起始点移动到画布底端（Y轴末端）
      context.translate(0, canvas.height);
      // 绘制以起始点为中心逆时针旋转90度
      context.rotate(2 * Math.PI * 90 / 360 * -1);
    }

    // 绘制图片
    context.drawImage(this.image, 0, 0, canvas.height, canvas.width);

    // 导出url
    let base64 = canvas.toDataURL(mime.getType(Img.getImgExt(this.image)));

    // 更改当前图片为新图并加载
    this.origin = base64;
    await this.init();

    return base64;
  }

  /**
   * @method clip
   * @desc 图片裁切
   * @example
   img.clip({
      x: 0, // 起始X坐标
      y: 0, // 起始Y坐标
      width: 0, // 切片宽度
      height: 0, // 切片高度
      returnType: 'base64', // 返回类型，base64字符串或者File对象。注意：当压缩图片后续操作是上传的话，returnType指定为'File'效率要高于'base64'
    });
   */
  async clip(param) {
    // 填充默认参数
    param = Object.assign({
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      returnType: 'base64',
    }, param);

    // 生成canvas
    let canvas = document.createElement('canvas');
    canvas.width = param.width;
    canvas.height = param.height;

    // 绘制图片到canvas
    let context = canvas.getContext('2d');
    context.drawImage(this.image, param.x, param.y, param.width, param.height, 0, 0, param.width, param.height);

    return await Img.canvasExport(canvas, param.returnType, Img.getImgExt(this));
  }

  /**
   * @method compress
   * @async
   * @desc 压缩图片
   * @param size {Number} 目标尺寸,单位B
   * @param returnType {'base64'|'File'} 返回类型，base64字符串或者File对象。注意：当压缩图片后续操作是上传的话，returnType指定为'File'效率要高于'base64'
   * @returns {base64|Promise} 当returnType指定为'File'时，返回Promise。
   */
  async compress(size, returnType = 'base64') {
    // 转成文件，获取尺寸，计算宽高比
    let file = await this.toFile();

    // 生成canvas
    let canvas = document.createElement('canvas');
    canvas.width = this.image.naturalWidth;
    canvas.height = this.image.naturalHeight;

    // canvas导出时的质量
    let quality = 0.92;

    // jpeg格式图片利用canvas原生的压缩能力
    if (Img.getImgExt(this).toLowerCase() === 'jpeg') {
      quality = size / file.size;

      // 其他格式图片利用利用缩放实现压缩
    } else {
      // 计算宽高缩放比
      let density = file.size / this.image.naturalWidth / this.image.naturalHeight;     // <- img.width * img.height * density = file.size
      let ratio = Math.sqrt(size / density / this.image.naturalWidth / this.image.naturalHeight);     // <- width * ratio * height * ratio * density = size

      // 设置宽高用于压缩
      canvas.width = this.image.naturalWidth * ratio;
      canvas.height = this.image.naturalHeight * ratio;
    }

    // 绘制图片到canvas
    let context = canvas.getContext('2d');
    context.drawImage(this.image, 0, 0, canvas.width, canvas.height);

    // 导出图片
    return await Img.canvasExport(canvas, returnType, Img.getImgExt(this), quality);
  }

  /**
   * @method autoCompress
   * @async
   * @desc 自动判断是否压缩图片
   * @param maxSize {Number} 最大图片体积,单位B，超出这个值时自动压缩图片到这个值
   * @param returnType {'base64'|'File'} 返回类型，base64字符串或者File对象。注意：当压缩图片后续操作是上传的话，returnType指定为'File'效率要高于'base64'
   * @returns {Promise} 当returnType指定为'File'时，返回Promise。
   */
  async autoCompress(maxSize, returnType = 'File') {
    // 转文件
    let file = await this.toFile();

    // 检测图片是否超出体积限制
    if (file.size > maxSize) {
      // 如超出，则压缩，返回'base64'|'File'
      if (returnType == 'base64' || returnType == 'File') {
        return await this.compress(maxSize, returnType);
      } else {
        throw new Error('returnType参数错误');
      }
      // 如未超出，则直接返回'base64'|'File'
    } else {
      if (returnType == 'base64') {
        return await this.toBase64();
      } else if (returnType == 'File') {
        return await this.toFile();
      } else {
        throw new Error('returnType参数错误');
      }
    }
  }

  /**
   * @method toFile
   * @async
   * @desc 将当前图片对象转化成File对象（注意：当遇到大文件时，该方法非常慢，所以尽量避免使用）
   * @returns {Promise}
   */
  async toFile() {
    // 如果是文件
    if (this.origin instanceof File) {
      return this.origin;
      // 如果是url
    } else {
      // 生成canvas
      let canvas = document.createElement('canvas');
      canvas.width = this.image.naturalWidth;
      canvas.height = this.image.naturalHeight;

      // 绘制图片到canvas
      let context = canvas.getContext('2d');
      context.drawImage(this.image, 0, 0, canvas.width, canvas.height);

      let fileType = Img.getImgExt(this.origin);
      let blob = await Img.canvasToBlob(canvas, fileType);
      return Img.blobToFile(blob, `file.${fileType}`, fileType);
    }
  }

  /**
   * @method toBase64
   * @desc 将当前图片对象转化成File对象
   * @returns {Promise}
   */
  toBase64() {
    // 如果有base64
    if (this.base64) {
      return this.base64;
      // 如果是url
    } else {
      // 生成canvas
      let canvas = document.createElement('canvas');
      canvas.width = this.image.naturalWidth;
      canvas.height = this.image.naturalHeight;

      // 绘制图片到canvas
      let context = canvas.getContext('2d');
      context.drawImage(this.image, 0, 0, canvas.width, canvas.height);

      // 开始导出
      return canvas.toDataURL(mime.getType(Img.getImgExt(this.image)));
    }
  }

  /**
   * @static
   * @method getImgExt
   * @desc 获取图片转换成文件后的扩展名
   * @param img {String(url)|File|Image|Img}
   * @returns {*|string}
   */
  static getImgExt(img) {
    let imgType = null;

    // 入参类型判断
    if (img instanceof File) {
      let file = img;
      imgType = file.type;
    } else if (img instanceof Blob) {
      let blob = img;
      imgType = blob.fileType || blob.type;
    } else if (type.isString(img) || img instanceof Image || img instanceof Img) {
      let url = null;
      if (type.isString(img)) {
        url = img;
      } else if (img instanceof Image) {
        url = img.src;
      } else if (img instanceof Img) {
        url = img.image.src;
      }

      // 从base64抓取图片类型
      let result = /^data:image\/(png|jpeg|gif);base64,(.+)$/.exec(url);

      // 如果从base64抓取不到图片类型
      if (!result) {
        // 从正常url抓取图片类型
        result = /\.(png|jpeg|gif|jpg)/.exec(url);
      }

      // 抓取结果
      imgType = result ? result[1] : null;
    }

    // 返回结果，如果抓取不到返回png
    return imgType || 'png';
  }

  /**
   * @static
   * @async
   * @method multiAutoCompress
   * @desc 批量自动压缩图片
   * @param img {String(url)|File|Image|Img}
   * @param maxSize {Number} 最大图片体积,单位MB，超出这个值时自动压缩图片到这个值
   * @param returnType {'base64'|'File'} 返回类型，base64字符串或者File对象。注意：当压缩图片后续操作是上传的话，returnType指定为'File'效率要高于'base64'
   * @returns {*|string}
   */
  static async multiAutoCompress(imgs, maxSize, returnType = 'File') {
    /*// 压缩队列，如果图片体积过大，压缩到最大可接受值
    return await Promise.all(imgs.map((img) => {
      return new Promise((resolve, reject) => {
        img = new Img(img);
        img.init().then(() => {
          img.autoCompress(maxSize * 1024 * 1024, returnType).then(resolve, reject);
        }, reject);
      });
    }));*/

    // 压缩队列，如果图片体积过大，压缩到最大可接受值
    return await Promise.all(imgs.map((img) => {
      return (async () => {
        img = new Img(img);
        await img.init();
        return await img.autoCompress(maxSize * 1024 * 1024, returnType);
      })();
    }));
  }

  /**
   * @static
   * @method base64ToBlob
   * @desc base64格式字符串转文件对象
   * @param base64 {String(base64)} base64字符串
   * @returns {Blob}
   */
  static base64ToBlob(base64) {
    // 如果图片url，则只取数据部分
    if (base64.indexOf('data:image') !== -1) {
      base64 = base64.split(',')[1];
    }

    // base64转文本，此处是字符串转换，并不能直接转成二进制
    let text = window.atob(base64);

    // 文本转ascii数组
    let asciiArray = text.split('').map(function (item) {
      return item.charCodeAt();
    });

    // 无符号8位整数，与Int8Array对应
    let uint8Array = new Uint8Array(asciiArray);

    // 二进制对象
    return new Blob([uint8Array], {type: type});
  }

  /**
   * @static
   * @method blobToFile
   * @desc Blob对象转File对象
   * @param blob {Blob}
   * @param fileName {String} 文件名
   * @param fileType {String} 文件类型
   * @returns {File}
   */
  static blobToFile(blob, fileName, fileType) {
    // ios8以下File不是构造函数，用blob类型替代
    if (Img.fileIsConstructor()) {
      return new File([blob], fileName, {type: fileType});
    } else {
      blob.name = fileName;
      blob.fileType = fileType;
      return blob;
    }
  }

  /**
   * @static
   * @method fileIsConstructor
   * @desc 检测File类型是否是构造函数，ios8以下File不是构造函数
   * @returns {Boolean}
   */
  static fileIsConstructor() {
    // return Object.prototype.toString.call(File) === '[object Function]';
    try {
      new File([], '');
      return true;
    } catch (err) {
      console.warn('当前环境下File不是构造函数:' + err);
      return false;
    }
  }

  /**
   * @static
   * @method canvasToBlob
   * @desc 将传入的canvas画布中图像导出为Blob。（目前只发现Android5.1及以下不支持canvas.toBlob，所以对canvas.toBlob做兼容性处理）
   * @param canvas {Canvas} 即将被导出的canvas
   * @param fileType {String} 导出的数据类型，如png/jpeg
   * @returns {Promise}
   */
  static canvasToBlob(canvas, fileType, quality = 1) {
    return new Promise((resolve, reject) => {
      if (canvas.toBlob) {
        canvas.toBlob(resolve, `image/${fileType}`, quality);
      } else {
        let base64 = canvas.toDataURL(`image/${fileType}`, quality);
        resolve(Img.base64ToBlob(base64));
      }
    });
  }

  /**
   * @static
   * @method canvasExport
   * @desc 图片合成，将多张图片合成一张图片
   * @param canvas {Canvas} 即将被导出的canvas
   * @param dataType {String} 导出的数据类型，取值范围（'base64'|'Blob'|'File'）
   * @param imgType {String} 导出的图片类型，取值范围（png|jpeg|jpg等）
   * @returns {Promise}
   */
  static async canvasExport(canvas, dataType, imgType, quality = 1) {
    // canvas导出图片为base64
    if (dataType == 'base64') {
      return canvas.toDataURL(mime.getType(imgType), quality); // type为image/jpeg或image/webp的情况下，quality才有效
      // canvas导出图片为Blob
    } else if (dataType == 'Blob') {
      return await Img.canvasToBlob(canvas, imgType, quality);
      // canvas导出图片为File
    } else if (dataType == 'File') {
      let blob = await Img.canvasToBlob(canvas, imgType, quality);
      return Img.blobToFile(blob, `file.${imgType}`, imgType);
    }
    throw new Error('参入参数dataType不在取值范围内');
  }

  /**
   * @static
   * @async
   * @method compound
   * @desc 图片合成功能，将多张图片、文字、二维码合成最重生成一张图片
   *
   * @param param {Object} 复合参数
   * @param param.ratio {Number} 实际生成的图片倍率，绘制过程中画布的大小和图片的x、y、width、height会和这个倍率相乘，可以根据实际需要设置为1、2、3等
   *  背景：实际运用中我们经常根据设计稿设置x、y、width、height，但生成的图片在高倍屏下展示是不清晰的
   *  举例：宽100px在2倍屏中以100px展示是不清晰的，此时需要将ratio设置为2生成200px宽度的图片以100px来展示，此时才是清晰的。
   *
   * @param param.canvas {Object} 画布属性
   * @param param.canvas.width {Number} 画布宽度，也就是最后导出的图片宽度
   * @param param.canvas.height {Number} 画布高度，也就是最后导出的图片高度
   *
   * @param param.returnType {'base64'|'Blob'|'File'} 返回的数据类型 {String}
   *
   * @param param.items {Array(Object)} 图片对象数组，根据图片在数组中的位置顺序依次绘制图片，如果发生重叠，位置靠后的图片会覆盖位置靠前的图片
   * @param param.items[i].type {'img'|'text'|'qrcode'} 可以设置图片、文本、二维码，根据type的不同取不同的属性
   *
   * @param param.items[type等于img].img {String(url)|File|Blob|Image} 图片源，取值范围
   * @param param.items[type等于img].x {Number|'%'} 相对于画布原点的X坐标，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的宽度）
   * @param param.items[type等于img].y {Number|'%'} 相对于画布原点的Y坐标，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的高度）
   * @param param.items[type等于img].width {Number|'%'} 图片被绘制到画布中后的宽度，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的宽度）
   *  如果不指定宽度或宽度设置为0则自动计算宽度(规则：如果指定了高度-则根据高度等比例缩放设置宽度，如果连高度都没有-则宽度等于原图片宽度)
   * @param param.items[type等于img].height {Number|'%'} 图片被绘制到画布中后的高度，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的高度）
   *  如果不指定高度或高度设置为0则自动计算高度(规则：如果指定了宽度-则根据宽度等比例缩放设置高度，如果连宽度都没有-则高度等于原图片高度)
   * @param param.items[type等于img].clip.x {Number} 相对于画布原点的X坐标
   * @param param.items[type等于img].clip.y {Number} 相对于画布原点的Y坐标
   * @param param.items[type等于img].clip.width {Number} 图片被绘制到画布中后的宽度
   * @param param.items[type等于img].clip.height {Number} 图片被绘制到画布中后的高度
   *
   * @param param.items[type等于text].hollow {Boolean} 是否空心文字
   * @param param.items[type等于text].x {Boolean} 相对于画布原点的X坐标，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的宽度）
   * @param param.items[type等于text].y {Boolean} 相对于画布原点的X坐标，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的高度）
   * @param param.items[type等于text].text {String} 文字内容
   * @param param.items[type等于text].text {String} 文字颜色，取值范围和CSS color相同
   * @param param.items[type等于text].fontSize {Number} 文字大小，单位px
   * @param param.items[type等于text].fontFamily {String} 文字字体
   * @param param.items[type等于text].align {'start'|'end'|'left'|'right'|'center'} 文字对齐方式，对齐的起始点是x坐标，默认值left
   * @param param.items[type等于text].baseline {'top'|'hanging'|'middle'|'alphabetic'|'ideographic'|'bottom'} 文字基线对齐方式，默认值alphabetic
   * @param param.items[type等于text].direction {'ltr'|'rtl'} 文本方向，默认值ltr
   * @param param.items[type等于text].shadow {Object} 文字阴影Y
   * @param param.items[type等于text].shadow.x {Number} 文字阴影X偏移量，默认值0
   * @param param.items[type等于text].shadow.y {Number} 文字阴影Y偏移量，默认值0
   * @param param.items[type等于text].shadow.blur {Number} 文字阴影Y偏移量，默认值0
   * @param param.items[type等于text].shadow.color {String} 文字阴影Y偏移量，默认值'black'
   *
   * @param param.items[type等于qrcode].x {Number} 相对于画布原点的X坐标，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的宽度）
   * @param param.items[type等于qrcode].y {Number} 相对于画布原点的Y坐标，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的高度）
   * @param param.items[type等于qrcode].width {Number|'%'} 图片被绘制到画布中后的宽度，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的宽度）
   *  如果不指定宽度或宽度设置为0则自动计算宽度(规则：如果指定了高度-则根据高度等比例缩放设置宽度，如果连高度都没有-则宽度等于原图片宽度)
   * @param param.items[type等于qrcode].height {Number|'%'} 图片被绘制到画布中后的高度，取值范围：{数字|百分比}（数字代表px，百分比是相对于画布的高度）
   *  如果不指定高度或高度设置为0则自动计算高度(规则：如果指定了宽度-则根据宽度等比例缩放设置高度，如果连宽度都没有-则高度等于原图片高度)
   * @param param.items[type等于qrcode].clip.x {Number} 相对于画布原点的X坐标
   * @param param.items[type等于qrcode].clip.y {Number} 相对于画布原点的Y坐标
   * @param param.items[type等于qrcode].clip.width {Number} 图片被绘制到画布中后的宽度
   * @param param.items[type等于qrcode].clip.height {Number} 图片被绘制到画布中后的高度
   * @param param.items[type等于qrcode].options {Object} 符合参数，此处调用dvd-base-js-qrcode模块生成二维码，具体请参见dvd-base-js-qrcode模块文档
   *
   * @returns {Promise}
   *
   * @example 演示项目地址，将来npm-test项目配置到charles本地启动看效果
   *  http://gitlab.rd.vyohui.com/FE-Service/npm-test.git
   *  http://18686604386.davdian.com/npm-test/dvd-base-js-img_compound.html
   */
  static async compound(param = {}) {
    // 填充默认参数
    param = Object.assign({
      canvas: {
        width: 100,
        height: 100,
      },
      ratio: 1,
      returnType: 'base64',
      items: [],
    }, param);

    // 每次绘画前样式重置
    function contextStyleReset(context) {
      // 文字样式
      context.font = `12px serif`;
      context.textAlign = 'start';
      context.textBaseline = 'alphabetic';
      context.direction = 'inherit';

      // 文字阴影
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
      context.shadowColor = 'black';
    }

    // 生成canvas
    let canvas = document.createElement('canvas');
    canvas.width = param.canvas.width * param.ratio;
    canvas.height = param.canvas.height * param.ratio;
    let context = canvas.getContext('2d');

    // 图片依次绘制到canvas
    for (let item of param.items) {
      // 每次绘画前样式重置
      contextStyleReset(context);

      // 没传这一项则不做处理
      if (!item) {
        continue;
      }

      // 图片和二维码
      if (item.type == 'img' || item.type == 'qrcode') {
        // 添加默认属性
        if (item.type == 'img') {
          item = Object.assign({
            type: 'img',
            img: '//pic.davdian.com/supplier/2018/04/16/800_800_654a289a31d3e70ec57be5d06ce6a3ea.jpg',
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            clip: {
              x: 0,
              y: 0,
              width: 0,
              height: 0,
            }
          }, item);
        } else if (item.type == 'qrcode') {
          item = Object.assign({
            type: 'qrcode',
            x: 0,
            y: 0,
            width: 100,
            height: 100,
            options: {}
          }, item);
        }

        // 如果是二维码，提前生成二维码并传给item.img
        if (item.type == 'qrcode') {
          item.img = await qrcode.getBase64(item.options);
        }

        // 等待图片加载完
        item.img = new Img(item.img);
        await item.img.init();

        // 如果传入的是百分比，则转为px
        item.x = item.x && type.isString(item.x) && item.x.indexOf('%') !== -1 ? param.canvas.width * window.parseInt(item.x) / 100 : item.x;
        item.y = item.y && type.isString(item.y) && item.y.indexOf('%') !== -1 ? param.canvas.height * window.parseInt(item.y) / 100 : item.y;
        item.width = item.width && type.isString(item.width) && item.width.indexOf('%') !== -1 ? param.canvas.width * window.parseInt(item.width) / 100 : item.width;
        item.height = item.height && type.isString(item.height) && item.height.indexOf('%') !== -1 ? param.canvas.height * window.parseInt(item.height) / 100 : item.height;

        // 原图宽高比
        let ratio = item.img.image.naturalWidth / item.img.image.naturalHeight;

        // 计算X坐标
        let x = item.x * param.ratio;

        // 计算X坐标
        let y = item.y * param.ratio;

        // 计算宽度，如果不指定宽度或宽度设置为0则自动计算宽度(规则：如果指定了高度-则根据高度等比例缩放设置宽度，如果连高度都没有-则宽度等于原图片宽度)
        let width = item.width && item.width * param.ratio || (item.height ? item.height * ratio : item.img.image.naturalWidth);

        // 计算高度，如果不指定高度或高度设置为0则自动计算高度(规则：如果指定了宽度-则根据宽度等比例缩放设置高度，如果连宽度都没有-则高度等于原图片高度)
        let height = item.height && item.height * param.ratio || (item.width ? item.width / ratio : item.img.image.naturalHeight);

        // 计算原图裁切的X坐标
        let sx = item.clip && item.clip.x || 0;

        // 计算原图裁切的Y坐标
        let sy = item.clip && item.clip.y || 0;

        // 计算原图裁切的宽度
        let swidth = item.clip && item.clip.width || item.img.image.naturalWidth;

        // 计算原图裁切的高度
        let sheight = item.clip && item.clip.height || item.img.image.naturalHeight;

        // 绘制单个图片
        context.drawImage(item.img.image, sx, sy, swidth, sheight, x, y, width, height);

      } else if (item.type == 'text') {
        // 添加文字默认属性
        item = Object.assign({
          type: 'text',
          hollow: false,
          x: 20,
          y: 20,
          text: '文字demo',
          color: 'red',
          fontSize: 12,
          fontFamily: 'serif',
          align: 'left',
          baseline: 'alphabetic',
          direction: 'ltr',
          shadow: {
            x: 0,
            y: 0,
            blur: 0,
            color: 'black',
          }
        }, item);

        // 文字样式
        context.font = `${item.fontSize * param.ratio}px ${item.fontFamily}`;
        context.textAlign = item.align;
        context.textBaseline = item.baseline;
        context.direction = item.direction;

        // 文字阴影
        context.shadowOffsetX = item.shadow.x * param.ratio;
        context.shadowOffsetY = item.shadow.y * param.ratio;
        context.shadowBlur = item.shadow.blur * param.ratio;
        context.shadowColor = item.shadow.color * param.ratio;

        // 绘制内容
        if (item.hollow) {
          context.strokeStyle = item.color;
          context.strokeText(item.text, item.x * param.ratio, item.y * param.ratio);
        } else {
          context.fillStyle = item.color;
          context.fillText(item.text, item.x * param.ratio, item.y * param.ratio);
        }

      }
    }

    // 导出图像
    return await Img.canvasExport(canvas, param.returnType, 'png');
  }

  /**
   * @static
   * @async
   * @method blobToBase64
   * @desc blob转base64（包括File也可以转base64)
   * @param blob {Blob|File}
   * @returns {Promise}
   */
  static async blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();

      reader.onload = (event) => {
        let base64 = event.target.result;

        // 解决ios最新版11.4中readAsDataURL导出图片格式不标准问题，标准dataurl为data:image/jpeg;base64,
        base64 = base64.replace(/data:(jpeg|png|jpg|gif);base64,/, `data:image/$1;base64,`);

        // android5.2读取blob返回的base64中有问题，此处做兼容处理
        if(base64.indexOf('[object object]') !== -1) {
          base64 = base64.replace(/\[object object]/, 'image/png');
        }

        resolve(base64);
      };

      reader.onerror = reject;

      reader.readAsDataURL(blob);
    });
  }
}
